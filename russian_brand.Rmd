```{r}
# Defining the question
#### use Uservised learning to learn the characteristics of customer groups of Kira Plastinina

# Metrics of success
#### Unsupervised Learning

# Understanding the context
#### Kira Plastinina is a Russian brand thais sold through a defunct chain of retail store in different parts of the world, for example, China and Belarus. The Brand's Sales and Marketing Team would like to understand their customer's behaviour from the data they collected oer the past year.

# Recording the Experimental Design
#### Use K-Means Clustering
#### use Hierachical Clustering

# Data Relevance
#### The data is from Kira Plastinina. Therefore we expect the data to be relevant. 
```


```{r}
# loading the data
russian <- read.csv("C:/Users/I/Downloads/online_shoppers_intention.csv")
```

```{r}
# Looking at the structure of the dataset
str(russian)
```
there are 12 numerical data, 2 factors and 2 logical data

```{r}
# Checking for the size of the dataset
dim(russian)
```
there are 12,380 rows and 18 columns
```{r}
# Checking for the column names
colnames(russian)
```
the column nams are not uniform. Hence we will need to standardise them during feature engineering
```{r}
# Previewing the top of the dataset
head(russian)
```

```{r}
# Previewing the bottom of the dataset
tail(russian)
```

# Data Wrangling
```{r}
# Checking for missing data in the dataset
colSums(is.na(russian))
```
there are 14 missing values in the first 8 features
```{r}
# Checking for duplicates
dup_rows <- russian[duplicated(russian), ]
dup_rows
```
there is presence of missing data
```{r}
# Checking for outliers
boxplot(russian$Administrative)
```
there is presence of missing data in the administrative feature. 
```{r}
boxplot(russian$Administrative_Duration)
```
there is presence of missing data in the administrative duration feature. 
```{r}
boxplot(russian$Informational)
```
there is presence of missing data in the informational feature. 
```{r}
boxplot(russian$Informational_Duration)
```
there is presence of missing data in the informational duraton feature. 
```{r}
boxplot(russian$ProductRelated)
```
there is presence of missing data in the product related feature. 
```{r}
boxplot(russian$ProductRelated_Duration)
```
there is presence of missing data in the product related duration feature. 
```{r}
boxplot(russian$BounceRates)
```
there is presence of missing data in the bounce rates feature. 
```{r}
boxplot(russian$ExitRates)
```
there is presence of missing data in the exit rates feature. 
```{r}
boxplot(russian$PageValues)
```
there is presence of missing data in the page values feature. 
```{r}
boxplot(russian$SpecialDay)
```
there is presence of missing data in the special day feature. 
```{r}
boxplot(russian$OperatingSystems)
```
there is presence of missing data in the operating systems feature. 
```{r}
boxplot(russian$Browser)
```
there is presence of missing data in the browser feature. 
```{r}
boxplot(russian$Region)
```
there is presence of missing data in the region feature. 
```{r}
boxplot(russian$TrafficType)
```
there is presence of missing data in the traffic type feature. 
```{r}
boxplot(russian$Weekend)
```
there is presence of missing data in the weekend feature. 
```{r}
boxplot(russian$Revenue)
```
there is presence of missing data in the revenue feature. 


# Dealing with Annomalies
```{r}
# removing missing data
# we are going to use the mice package to make predictions on the missing values
install.packages("mice")
library(mice)
mice_mod <- mice(russian[, c("Administrative","Administrative_Duration","Informational","Informational_Duration","ProductRelated","ProductRelated_Duration","BounceRates","ExitRates" )], method='rf')
install.packages("mice")
mice_complete <- complete(mice_mod)
```

```{r}
# we now transfer the missing data values in the dataset
russian$Administrative <- mice_complete$Administrative
russian$Administrative_Duration <- mice_complete$Administrative_Duration
russian$Informational <- mice_complete$Informational
russian$Informational_Duration <- mice_complete$Informational_Duration
russian$ProductRelated <- mice_complete$ProductRelated
russian$ProductRelated_Duration <- mice_complete$ProductRelated_Duration
russian$BounceRates <- mice_complete$BounceRates
russian$ExitRates <- mice_complete$ExitRates
```

```{r}
# we are now going to remove the duplicates that are in the datasets
library(dplyr)
russia <- russian
distinct(russian, .keep_all= TRUE)
duplicated(russian)
russian[duplicated(russian),]
russian[duplicated(!russian),]
```
# the are no absolute reason that we should remove the outliers because they seem valid

```{r}
# Standardising the column names
names(russian)[names(russian) == "Administrative"] <- "administrative"
names(russian)[names(russian) == "Administrative_Duration"] <- "administrative_duration"
names(russian)[names(russian) == "Informational"] <- "informational"
names(russian)[names(russian) == "Informational_Duration"] <- "informational_duration"
names(russian)[names(russian) == "ProductRelated"] <- "product_related"
names(russian)[names(russian) == "ProductRelated_Duration"] <- "product_related_duration"
names(russian)[names(russian) == "BounceRates"] <- "bounce_rates"
names(russian)[names(russian) == "ExitRates"] <- "exit_rates"
names(russian)[names(russian) == "PageValues"] <- "page_values"
names(russian)[names(russian) == "SpecialDay"] <- "special_day"
names(russian)[names(russian) == "Month"] <- "month"
names(russian)[names(russian) == "Operatingsystems"] <- "operating_systems"
names(russian)[names(russian) == "Browser"] <- "browser"
names(russian)[names(russian) == "Region"] <- "region"
names(russian)[names(russian) == "TrafficType"] <- "traffic_type"
names(russian)[names(russian) == "VisitorType"] <- "visitor_type"
names(russian)[names(russian) == "Weekend"] <- "weekend"
names(russian)[names(russian) == "Revenue"] <- "revenue"
```

```{r}
# converting the revenue column to a factor since it our label
b = c('revenue')
for (i in b) {
russian[,i] = as.factor(russian[,i])
}
```

# Univariate Analysis
```{r}
hist(russian$administrative,
main="Administrative",
xlab = "Administrative",
col='green')
```
data is skewed to the right and most of the data is skewed between 0 and 5  
```{r}
hist(russian$administrative_duration,
main= "Administrative Duration",
xlab= "Administrative Duration",
col= "green")
```
data is skewed to the right and most of the data is skewed between 0 and 250 
```{r}
hist(russian$informational,
main =  "Informational",
xlab = "Informational",
col = "red")
```
data is skewed to the right and most of the data is skewed between 0 and 3
```{r}
hist(russian$informational_duration,
main = "Informational Duration",
xlab= "Informational Duration",
col = "blue")
```
data is skewed to the right and most of the data is skewed between 0 and 250

```{r}
hist(russian$product_related,
main = "Product Related",
xlab = "Product Related",
col = "blue")
```
data is skewed to the right and most of the data is skewed between 0 and 100
```{r}
hist(russian$product_related_duration,
main = "Product Related Duration",
xlab = "Product Related Duration",
col = "red")
```
data is skewed to the right and most of the data is skewed between 0 and 10,000
```{r}
hist(russian$bounce_rates,
main = "Bounce Rates",
xlab = "Bounce Rates",
col = "purple")
```
data is skewed to the right and most of the data is skewed between 0 and 0.02
```{r}
hist(russian$exit_rates,
main = "Exit Rates",
xlab = "Exit Rates",
col = "blue")
```
data is skewed to the right and most of the data is skewed between 0 and 0.05
```{r}
hist(russian$page_values,
main = "Page Values",
xlab = "Page Values",
col = "blue")
```
data is skewed to the right and most of the data is skewed between 0 and 25
```{r}
barplot(table(russian$special_day),
main = "Special Day",
xlab = "Special Day",
col = "blue")
```
the special day of 0 has the most visits
```{r}
barplot(table(russian$month),
main = "Month",
xlab = "Month",
col = "blue")
```
the month of May had most visits
```{r}
barplot(table(russian$OperatingSystems),
main = "Operating Systems",
xlab = "Operating Systems",
col = "green")
```
operating systems 2 is the most used to access the website
```{r}
barplot(table(russian$browser),
main = "browser",
xlab = "browser",
col = "green")
```
browser 2 is the most used to access the website
```{r}
barplot(table(russian$region),
main = "region",
xlab = "region",
col = "green")
```
region 1 has the most number of people visiting the system
```{r}
barplot(table(russian$traffic_type),
main = "Traffic Type",
xlab = "Traffic Type",
col = "green")
```
traffic type 2 is has the most visits
```{r}
barplot(table(russian$visitor_type),
main = "Visitor Type",
xlab = "Visitor Type",
col = "blue")
```
returning visitorsare the most frequent visitors of the website
```{r}
barplot(table(russian$weekend),
main = "Weekend",
xlab = "Weekend",
col = "green")
```
most visit are done during the weekdays
```{r}
barplot(table(russian$revenue),
main = "Revenue",
xlab = "Revenue",
col = "black")
```
revenue collected by the company is less compared to the one that is not collected

#Bivariate Analysis
```{r}
# we are going to import the library that is responsible for visualisations
library(ggplot2)
```

```{r}
# administrative ve revenue
admin =ggplot(data=russian, aes(x=administrative, fill= revenue)) + geom_bar()
admin
```
generally, there is less revenue collected from the administrative page
```{r}
# informational vs revenue
info = ggplot(data = russian, aes(x = informational, fill= revenue)) + geom_bar()
info
```
generally, there is less revenue collected from the informational page
```{r}
# Product related vs revenue
product = ggplot(data = russian, aes(x = product_related, fill= revenue)) + geom_bar()
product
```
generally, there is less revenue collected from the product related page
```{r}
# Product related vs revenue
product = ggplot(data = russian, aes(x = special_day, fill= revenue)) + geom_bar()
product
```
generally, there is less revenue collected in the special days
most of the revenue is collected during the special day of 0
```{r}
# Product related vs revenue
product = ggplot(data = russian, aes(x = month, fill= revenue)) + geom_bar()
product
```
generally, there is less revenue collected through out the year
November made a lot revenue
```{r}
# Product related vs revenue
product = ggplot(data = russian, aes(x = OperatingSystems, fill= revenue)) + geom_bar()
product
```
operating system 2 helps the brand to generate revenue  
```{r}
# Product related vs revenue
product = ggplot(data = russian, aes(x = browser, fill= revenue)) + geom_bar()
product
```
browser 2 helps the brand to generate a lot of revenue
```{r}
# Product region vs revenue
product = ggplot(data = russian, aes(x = region, fill= revenue)) + geom_bar()
product
```
Alot of revenue is collected from region 1
```{r}
# Product related vs revenue
product = ggplot(data = russian, aes(x = traffic_type, fill= revenue)) + geom_bar()
product
```
the second type of traffic helps the brand generate a lot of revenue
```{r}
# Product related vs revenue
product = ggplot(data = russian, aes(x = visitor_type, fill= revenue)) + geom_bar()
product
```
returning visitors are the ones who are making the brand generate a lot of revenue compared to other types of visitors
```{r}
# Product related vs revenue
product = ggplot(data = russian, aes(x = weekend, fill= revenue)) + geom_bar()
product
```
Most of the revenue is generated during the weekdays

# Modelling
###K-Means
```{r}
# Preprocessing the data
# for clustering is a form of unsupervised learning,
# we are going to remove the dependent variable and assign it a separate variable from the independent variables.
# then, we shall normalise the independent variable.
russian.new <- russian[, c(1,2,3,4,5,6,7,8,9,10,12,13,14,15,17)]
russian.class <- russian[, "revenue"]
head(russian.new)
```

```{r}
# previewing the dependent variable
head(russian.class)
```

```{r}
# converting categorical data to numerical data
a = c('month', 'visitor_type', "weekend")
for (i in a) {
russian[,i] = as.factor(russian[,i])
}
```

```{r}
# normalizing the dataset so as no particular attribute has more impact than another
normalize <- function(x){
return ((x-min(x)) / (max(x)-min(x)))
}
russian.new$administrative <- normalize(russian.new$administrative)
russian.new$administrative_duration <- normalize(russian.new$administrative_duration)
russian.new$informational <- normalize(russian.new$informational)
russian.new$informational_duration <- normalize(russian.new$informational_duration)
russian.new$product_related <- normalize(russian.new$product_related)
russian.new$product_related_duration <- normalize(russian.new$product_related_duration)
russian.new$bounce_rates <- normalize(russian.new$bounce_rates)
russian.new$exit_rates <- normalize(russian.new$exit_rates)
russian.new$page_values <- normalize(russian.new$page_values)
russian.new$special_day <- normalize(russian.new$special_day)
#russian.new$month <- normalize(russian.new$month)
russian.new$OperatingSystems <- normalize(russian.new$OperatingSystems)
russian.new$browser <- normalize(russian.new$browser)
russian.new$region <- normalize(russian.new$browser)
russian.new$traffic_type <- normalize(russian.new$traffic_type)
#russian.new$visitor_type <- normalize(russian.new$visitor_type)
russian.new$weekend <- normalize(russian.new$weekend)
```

```{r}
# Applying the K-means clustering algorithm with no. of centroids(k)=5
result <- kmeans(na.omit(russian.new),2)
```

```{r}
# Previewing the no. of records in each cluster
result$size
```

```{r}
# Getting the value of the cluster center
result$centers
```

```{r}
# Getting the cluster vector that shows the cluster where each record falls
dim(result$cluster)
```

```{r}
# visualising the clustering results
par(mfrow = c(2,2), mar = c(5,2,2,2))
plot(russian.new[c(1,2)], col = result$cluster)

# Plotting to see how Sepal.Length and Sepal.Width data points have been distributed
# originally as per "class" attribute in dataset
# ---
#
plot(russian.new[c(2,2)], col = russian.class)
plot(russian.new[c(3,2)], col = result$cluster)
plot(russian.new[c(4,2)], col = russian.class)
```


```{r}
table(result$cluster, russian.class)
```
the true value has less revenue made than the false.

# strengths
#### it was easy to implement
#### An instance can change cluster (move to another cluster) when the centroids are recomputed

# weaknesses
#### it was difficult to predict the number of clusters (K-Value)
#### The order of the data has an impact on the final results
# Clustering


```{r}
d <- dist(russian, method = "euclidean")
res.hc <- hclust(d, method = "ward.D2" )
plot(res.hc, cex = 0.6, hang = -1)
```
# strengths
#### It was easy to implement
#### We did not need to specify the number of clusters required for the algorithm.
# weaknesses
#### There was no mathematical objective for Hierarchical clustering.
#### High space and time complexity for Hierarchical clustering. Hence this clustering algorithm cannot be used when we have huge data.